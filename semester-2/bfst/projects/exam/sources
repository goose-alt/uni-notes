% Encoding: UTF-8

@Misc{ikonli,
  author = {Andres Almiray and contributors},
  note   = {Version used: 12.2.0},
  title  = {Ikonli},
  groups = {BFST21},
  url    = {https://github.com/kordamp/ikonli},
}

@Misc{javafx,
  author = {Contributors},
  note   = {Version used:},
  title  = {OpenJFX},
  groups = {BFST21},
  url    = {https://github.com/openjdk/jfx},
}

@Misc{material-design,
  author = {Google},
  title  = {Material Design},
  groups = {BFST21},
  url    = {https://material.io/},
}

@Misc{font-awesome,
  author = {Fonticons, Inc. and contributors},
  title  = {Font Awesome},
  groups = {BFST21},
  url    = {https://fontawesome.com/},
}

@Misc{jfoenix,
  author = {JFoenix and contributors},
  title  = {JFoenix},
  groups = {BFST21},
  url    = {http://www.jfoenix.com/},
}

@InProceedings{r-star,
  author     = {Beckmann, Norbert and Kriegel, Hans-Peter and Schneider, Ralf and Seeger, Bernhard},
  title      = {The R*-Tree: An Efficient and Robust Access Method for Points and Rectangles},
  year       = {1990},
  address    = {New York, NY, USA},
  month      = may,
  number     = {2},
  pages      = {322–331},
  publisher  = {Association for Computing Machinery},
  volume     = {19},
  abstract   = {The R-tree, one of the most popular access methods for rectangles, is based on the heuristic optimization of the area of the enclosing rectangle in each inner node. By running numerous experiments in a standardized testbed under highly varying data, queries and operations, we were able to design the R*-tree which incorporates a combined optimization of area, margin and overlap of each enclosing rectangle in the directory. Using our standardized testbed in an exhaustive performance comparison, it turned out that the R*-tree clearly outperforms the existing R-tree variants. Guttman's linear and quadratic R-tree and Greene's variant of the R-tree. This superiority of the R*-tree holds for different types of queries and operations, such as map overlay, for both rectangles and multidimensional points in all experiments. From a practical point of view the R*-tree is very attractive because of the following two reasons 1 it efficiently supports point and spatial data at the same time and 2 its implementation cost is only slightly higher than that of other R-trees.},
  doi        = {10.1145/93605.98741},
  issn       = {0163-5808},
  issue_date = {Jun. 1990},
  journal    = {SIGMOD Rec.},
  numpages   = {10},
  url        = {https://doi.org/10.1145/93605.98741},
}

@Article{rtree-nn,
  author     = {Hjaltason, G\'isli R. and Samet, Hanan},
  journal    = {ACM Trans. Database Syst.},
  title      = {Distance Browsing in Spatial Databases},
  year       = {1999},
  issn       = {0362-5915},
  month      = jun,
  number     = {2},
  pages      = {265–318},
  volume     = {24},
  abstract   = {We compare two different techniques for browsing through a collection of spatial objects stored in an R-tree spatial data structure on the basis of their distances from an arbitrary spatial query object. The conventional approach is one that makes use of a k-nearest neighbor algorithm where k is known prior to the invocation of the algorithm. Thus if m &lt; k neighbors are needed, the k-nearest neighbor algorithm has to be reinvoked for m neighbors, thereby possibly performing some redundant computations. The second approach is incremental in the sense that having obtained the k nearest neighbors, the k + 1st neighbor can be  obtained without having to calculate the k + 1 nearest neighbors from scratch. The incremental approach is useful when processing complex queries where one of the conditions involves spatial proximity (e.g., the nearest city to Chicago with population greater than a million), in which case a query engine can make use of a pipelined strategy. We present a general incremental nearest neighbor algorithm that is applicable to a large class of hierarchical spatial data structures. This algorithm is adapted to the R-tree and its performance is compared to an existing k-nearest  neighbor algorithm for R-trees [Rousseopoulos et al. 1995]. Experiments show that the incremental nearest neighbor algorithm significantly outperforms the k-nearest  neighbor algorithm for distance browsing queries in a spatial database that uses the R-tree as a spatial index. Moreover, the incremental nearest neighbor algorithm usually outperforms the k-nearest neighber algorithm when applied to the k-nearest neighbor problem for the R-tree, although the improvement is not nearly as large as for distance browsing queries. In fact, we prove informally that at any step in its execution the incremental nearest neighbor algorithm is optimal with respect to the spatial data structure that is employed. Furthermore, based on some simplifying assumptions, we prove that in two dimensions the number of distance computations and leaf nodes accesses made by the algorithm for finding k neighbors is  O(k + k).},
  address    = {New York, NY, USA},
  doi        = {10.1145/320248.320255},
  issue_date = {June 1999},
  keywords   = {R-trees, hiearchical spatial data structures, ranking, distance browsing, nearest neighbors},
  numpages   = {54},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/320248.320255},
}

@Comment{jabref-meta: databaseType:bibtex;}

@Comment{jabref-meta: grouping:
0 AllEntriesGroup:;
1 StaticGroup:BFST21\;0\;1\;0x8a8a8aff\;\;\;;
}
